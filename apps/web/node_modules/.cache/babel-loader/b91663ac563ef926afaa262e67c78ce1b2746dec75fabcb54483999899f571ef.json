{"ast":null,"code":"/**\r\n * CANVAS UTILITIES - IMPROVED VERSION\r\n * Fixes:\r\n * 1. Drag & Drop vào Section\r\n * 2. Child element positioning (tọa độ tự do)\r\n * 3. Auto spacing & layout\r\n */\n\nimport { toast } from 'react-toastify';\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\nexport const ItemTypes = {\n  ELEMENT: 'element',\n  EXISTING_ELEMENT: 'existingElement',\n  CHILD_ELEMENT: 'childElement'\n};\nexport const GRID_SIZE = 10;\nexport const SNAP_THRESHOLD = 15;\n\n// Default spacing cho auto layout\nexport const AUTO_SPACING = {\n  vertical: 20,\n  // Khoảng cách giữa các elements theo chiều dọc\n  horizontal: 20,\n  // Khoảng cách giữa các elements theo chiều ngang\n  padding: 20 // Padding từ parent container\n};\n\n// ============================================================================\n// POSITION CALCULATION\n// ============================================================================\n\n/**\r\n * Tính position tuyệt đối trong canvas (bao gồm cả nested elements)\r\n */\nexport const getAbsolutePosition = (element, parentElement = null) => {\n  var _element$position, _parentElement$positi;\n  const elementPos = ((_element$position = element.position) === null || _element$position === void 0 ? void 0 : _element$position.desktop) || {\n    x: 0,\n    y: 0,\n    z: 1\n  };\n  if (!parentElement) {\n    return elementPos;\n  }\n  const parentPos = ((_parentElement$positi = parentElement.position) === null || _parentElement$positi === void 0 ? void 0 : _parentElement$positi.desktop) || {\n    x: 0,\n    y: 0,\n    z: 1\n  };\n  return {\n    x: parentPos.x + elementPos.x,\n    y: parentPos.y + elementPos.y,\n    z: Math.max(parentPos.z || 1, elementPos.z || 1)\n  };\n};\n\n/**\r\n * Tính position tương đối so với parent\r\n */\nexport const getRelativePosition = (absolutePos, parentElement) => {\n  var _parentElement$positi2;\n  if (!parentElement) {\n    return absolutePos;\n  }\n  const parentPos = ((_parentElement$positi2 = parentElement.position) === null || _parentElement$positi2 === void 0 ? void 0 : _parentElement$positi2.desktop) || {\n    x: 0,\n    y: 0,\n    z: 1\n  };\n  return {\n    x: absolutePos.x - parentPos.x,\n    y: absolutePos.y - parentPos.y,\n    z: absolutePos.z || 1\n  };\n};\n\n/**\r\n * Tính canvas position từ mouse event\r\n * FIXED: Xử lý cả nested containers (section)\r\n */\nexport const getCanvasPosition = (mouseX, mouseY, containerElement, zoomLevel = 100, parentElement = null) => {\n  if (!containerElement) {\n    console.error('Container element is null in getCanvasPosition');\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const rect = containerElement.getBoundingClientRect();\n  const scrollX = containerElement.scrollLeft || 0;\n  const scrollY = containerElement.scrollTop || 0;\n\n  // Tính position tuyệt đối trong canvas\n  const rawX = (mouseX - rect.left + scrollX) / (zoomLevel / 100);\n  const rawY = (mouseY - rect.top + scrollY) / (zoomLevel / 100);\n  let x = Math.max(0, rawX);\n  let y = Math.max(0, rawY);\n\n  // Nếu có parent element (drop vào section), tính relative position\n  if (parentElement) {\n    var _parentElement$positi3;\n    const parentPos = ((_parentElement$positi3 = parentElement.position) === null || _parentElement$positi3 === void 0 ? void 0 : _parentElement$positi3.desktop) || {\n      x: 0,\n      y: 0\n    };\n    x = Math.max(0, x - parentPos.x);\n    y = Math.max(0, y - parentPos.y);\n\n    // Constrain trong bounds của parent\n    const parentSize = parentElement.size || {\n      width: 1200,\n      height: 400\n    };\n    x = Math.min(x, parentSize.width - 50);\n    y = Math.min(y, parentSize.height - 50);\n  }\n  return {\n    x,\n    y\n  };\n};\n\n/**\r\n * Check xem point có nằm trong element bounds không\r\n */\nexport const isPointInElement = (point, element) => {\n  var _element$position2;\n  const pos = ((_element$position2 = element.position) === null || _element$position2 === void 0 ? void 0 : _element$position2.desktop) || {\n    x: 0,\n    y: 0\n  };\n  const size = element.size || {\n    width: 200,\n    height: 50\n  };\n  return point.x >= pos.x && point.x <= pos.x + size.width && point.y >= pos.y && point.y <= pos.y + size.height;\n};\n\n/**\r\n * Tìm parent element chứa point (cho nested drop)\r\n */\nexport const findParentAtPosition = (point, elements, excludeId = null) => {\n  // Lọc các elements có thể là container (section, container, etc)\n  const containers = elements.filter(el => el.type === 'section' && el.id !== excludeId && isPointInElement(point, el));\n\n  // Return container có z-index cao nhất\n  if (containers.length === 0) return null;\n  return containers.reduce((highest, current) => {\n    var _current$position, _current$position$des, _highest$position, _highest$position$des;\n    const currentZ = ((_current$position = current.position) === null || _current$position === void 0 ? void 0 : (_current$position$des = _current$position.desktop) === null || _current$position$des === void 0 ? void 0 : _current$position$des.z) || 1;\n    const highestZ = ((_highest$position = highest.position) === null || _highest$position === void 0 ? void 0 : (_highest$position$des = _highest$position.desktop) === null || _highest$position$des === void 0 ? void 0 : _highest$position$des.z) || 1;\n    return currentZ > highestZ ? current : highest;\n  });\n};\n\n// ============================================================================\n// SNAPPING & GRID\n// ============================================================================\n\n/**\r\n * Snap to grid với smart snapping\r\n */\nexport const snapToGrid = (x, y, gridSize = GRID_SIZE, snapPoints = [], enabled = true) => {\n  if (!enabled) {\n    return {\n      x,\n      y\n    };\n  }\n  let snappedX = Math.round(x / gridSize) * gridSize;\n  let snappedY = Math.round(y / gridSize) * gridSize;\n\n  // Snap to nearby elements\n  snapPoints.forEach(point => {\n    if (Math.abs(x - point.x) < SNAP_THRESHOLD) snappedX = point.x;\n    if (Math.abs(y - point.y) < SNAP_THRESHOLD) snappedY = point.y;\n  });\n  return {\n    x: snappedX,\n    y: snappedY\n  };\n};\n\n/**\r\n * Generate snap points từ tất cả elements\r\n */\nexport const generateSnapPoints = (elements, excludeId = null) => {\n  const points = [];\n  elements.forEach(element => {\n    if (element.id === excludeId) return;\n    const bounds = getElementBounds(element);\n\n    // Add các edge points\n    points.push({\n      x: bounds.left,\n      y: bounds.top\n    }, {\n      x: bounds.right,\n      y: bounds.top\n    }, {\n      x: bounds.left,\n      y: bounds.bottom\n    }, {\n      x: bounds.right,\n      y: bounds.bottom\n    }, {\n      x: bounds.centerX,\n      y: bounds.centerY\n    });\n  });\n  return points;\n};\n\n/**\r\n * Get element bounds\r\n */\nexport const getElementBounds = (element, viewMode = 'desktop') => {\n  var _element$position3;\n  const pos = ((_element$position3 = element.position) === null || _element$position3 === void 0 ? void 0 : _element$position3[viewMode]) || {\n    x: 0,\n    y: 0\n  };\n  const size = element.size || {\n    width: 200,\n    height: 50\n  };\n  return {\n    left: pos.x,\n    top: pos.y,\n    right: pos.x + size.width,\n    bottom: pos.y + size.height,\n    centerX: pos.x + size.width / 2,\n    centerY: pos.y + size.height / 2,\n    width: size.width,\n    height: size.height\n  };\n};\n\n// ============================================================================\n// AUTO LAYOUT & SPACING\n// ============================================================================\n\n/**\r\n * Tính position tự động cho child element mới\r\n * Có 2 modes: 'flow' (auto spacing) và 'free' (tọa độ tự do)\r\n */\nexport const calculateChildPosition = (parentElement, existingChildren = [], mode = 'flow',\n// 'flow' hoặc 'free'\ndropPosition = null // Position khi drop (cho free mode)\n) => {\n  const parentSize = parentElement.size || {\n    width: 1200,\n    height: 400\n  };\n  const padding = AUTO_SPACING.padding;\n  if (mode === 'free' && dropPosition) {\n    // Free positioning - sử dụng drop position\n    return {\n      x: Math.max(padding, Math.min(dropPosition.x, parentSize.width - padding - 100)),\n      y: Math.max(padding, Math.min(dropPosition.y, parentSize.height - padding - 50)),\n      z: 2 // Child elements có z-index cao hơn parent\n    };\n  }\n\n  // Flow mode - auto spacing theo chiều dọc\n  if (existingChildren.length === 0) {\n    // Child đầu tiên\n    return {\n      x: padding,\n      y: padding,\n      z: 2\n    };\n  }\n\n  // Tìm child thấp nhất\n  let maxBottom = padding;\n  existingChildren.forEach(child => {\n    var _child$position;\n    const childPos = ((_child$position = child.position) === null || _child$position === void 0 ? void 0 : _child$position.desktop) || {\n      x: padding,\n      y: padding\n    };\n    const childSize = child.size || {\n      width: 200,\n      height: 50\n    };\n    const bottom = childPos.y + childSize.height;\n    if (bottom > maxBottom) {\n      maxBottom = bottom;\n    }\n  });\n\n  // Child mới nằm dưới child thấp nhất\n  return {\n    x: padding,\n    y: maxBottom + AUTO_SPACING.vertical,\n    z: 2\n  };\n};\n\n/**\r\n * Auto-layout lại tất cả children trong parent\r\n * Useful sau khi delete hoặc reorder\r\n */\nexport const autoLayoutChildren = (parentElement, children, mode = 'flow') => {\n  if (mode === 'free') {\n    // Free mode - giữ nguyên positions\n    return children;\n  }\n  const padding = AUTO_SPACING.padding;\n  let currentY = padding;\n  return children.map(child => {\n    const childSize = child.size || {\n      width: 200,\n      height: 50\n    };\n    const updatedChild = {\n      ...child,\n      position: {\n        ...child.position,\n        desktop: {\n          x: padding,\n          y: currentY,\n          z: 2\n        }\n      }\n    };\n    currentY += childSize.height + AUTO_SPACING.vertical;\n    return updatedChild;\n  });\n};\n\n/**\r\n * Check và fix overflow children\r\n */\nexport const constrainChildrenToParent = (parentElement, children) => {\n  const parentSize = parentElement.size || {\n    width: 1200,\n    height: 400\n  };\n  const padding = AUTO_SPACING.padding;\n  return children.map(child => {\n    var _child$position2;\n    const childPos = ((_child$position2 = child.position) === null || _child$position2 === void 0 ? void 0 : _child$position2.desktop) || {\n      x: 0,\n      y: 0\n    };\n    const childSize = child.size || {\n      width: 200,\n      height: 50\n    };\n    const constrainedX = Math.max(padding, Math.min(childPos.x, parentSize.width - childSize.width - padding));\n    const constrainedY = Math.max(padding, Math.min(childPos.y, parentSize.height - childSize.height - padding));\n    if (constrainedX !== childPos.x || constrainedY !== childPos.y) {\n      return {\n        ...child,\n        position: {\n          ...child.position,\n          desktop: {\n            x: constrainedX,\n            y: constrainedY,\n            z: childPos.z || 2\n          }\n        }\n      };\n    }\n    return child;\n  });\n};\n\n// ============================================================================\n// DRAG & DROP HANDLERS\n// ============================================================================\n\n/**\r\n * Handle drop element mới vào canvas/section\r\n */\nexport const handleDropNewElement = (item, mousePosition, containerElement, zoomLevel, allElements, parentElement = null, layoutMode = 'flow') => {\n  let position;\n  if (parentElement) {\n    // Drop vào section\n    if (layoutMode === 'free') {\n      // Tọa độ tự do - dùng mouse position\n      const relativePos = getCanvasPosition(mousePosition.x, mousePosition.y, containerElement, zoomLevel, parentElement);\n      position = {\n        desktop: {\n          x: relativePos.x,\n          y: relativePos.y,\n          z: 2\n        }\n      };\n    } else {\n      // Flow mode - auto positioning\n      const children = parentElement.children || [];\n      const autoPos = calculateChildPosition(parentElement, children, 'flow');\n      position = {\n        desktop: autoPos\n      };\n    }\n  } else {\n    // Drop vào canvas chính\n    const canvasPos = getCanvasPosition(mousePosition.x, mousePosition.y, containerElement, zoomLevel);\n\n    // Snap to grid\n    const snapPoints = generateSnapPoints(allElements);\n    const snapped = snapToGrid(canvasPos.x, canvasPos.y, GRID_SIZE, snapPoints);\n    position = {\n      desktop: {\n        x: snapped.x,\n        y: snapped.y,\n        z: 1\n      }\n    };\n  }\n  return position;\n};\n\n/**\r\n * Handle di chuyển existing element\r\n */\nexport const handleMoveElement = (element, newPosition, allElements, parentElement = null, snapEnabled = true) => {\n  var _element$position4, _element$position4$de;\n  let finalPosition = {\n    ...newPosition\n  };\n  if (snapEnabled && !parentElement) {\n    // Snap to grid (chỉ trên canvas chính)\n    const snapPoints = generateSnapPoints(allElements, element.id);\n    finalPosition = snapToGrid(newPosition.x, newPosition.y, GRID_SIZE, snapPoints);\n  }\n  if (parentElement) {\n    // Constrain trong parent bounds\n    const parentSize = parentElement.size || {\n      width: 1200,\n      height: 400\n    };\n    const elementSize = element.size || {\n      width: 200,\n      height: 50\n    };\n    const padding = AUTO_SPACING.padding;\n    finalPosition.x = Math.max(padding, Math.min(finalPosition.x, parentSize.width - elementSize.width - padding));\n    finalPosition.y = Math.max(padding, Math.min(finalPosition.y, parentSize.height - elementSize.height - padding));\n  }\n  return {\n    desktop: {\n      x: finalPosition.x,\n      y: finalPosition.y,\n      z: newPosition.z || ((_element$position4 = element.position) === null || _element$position4 === void 0 ? void 0 : (_element$position4$de = _element$position4.desktop) === null || _element$position4$de === void 0 ? void 0 : _element$position4$de.z) || 1\n    }\n  };\n};\n\n// ============================================================================\n// UTILITIES\n// ============================================================================\n\n/**\r\n * Convert camelCase to kebab-case\r\n */\nexport const toKebabCase = str => str.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`);\n\n/**\r\n * Process styles including pseudo-classes\r\n */\nexport const processStyles = (styles, className) => {\n  let cssString = '';\n  const keyframes = {};\n  Object.entries(styles).forEach(([key, value]) => {\n    if (key.startsWith(':')) {\n      cssString += `.${className}${key} { `;\n      Object.entries(value).forEach(([prop, val]) => {\n        if (prop.startsWith('::')) {\n          cssString += `.${className}${prop} { `;\n          Object.entries(val).forEach(([p, v]) => {\n            cssString += `${toKebabCase(p)}: ${v}; `;\n          });\n          cssString += '} ';\n        } else {\n          cssString += `${toKebabCase(prop)}: ${val}; `;\n        }\n      });\n      cssString += '} ';\n    } else if (key.startsWith('@keyframes')) {\n      keyframes[key] = value;\n    } else {\n      cssString += `${toKebabCase(key)}: ${value}; `;\n    }\n  });\n  Object.entries(keyframes).forEach(([key, frames]) => {\n    cssString += `${key} { `;\n    Object.entries(frames).forEach(([percentage, props]) => {\n      cssString += `${percentage} { `;\n      Object.entries(props).forEach(([prop, val]) => {\n        cssString += `${toKebabCase(prop)}: ${val}; `;\n      });\n      cssString += '} ';\n    });\n    cssString += '} ';\n  });\n  return cssString;\n};\n\n/**\r\n * Get clean text styles (remove incompatible properties)\r\n */\nexport const getCleanTextStyles = originalStyles => {\n  const cleaned = {\n    ...originalStyles\n  };\n  const propertiesToRemove = ['border', 'borderRadius', 'boxShadow', 'backgroundColor', 'background', 'backgroundImage', 'backgroundSize', 'backgroundPosition', 'padding', 'paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'];\n  propertiesToRemove.forEach(prop => delete cleaned[prop]);\n  return {\n    ...cleaned,\n    margin: cleaned.margin || '0',\n    boxSizing: 'border-box',\n    display: cleaned.display || 'block',\n    width: cleaned.width || '100%',\n    height: cleaned.height || 'auto'\n  };\n};\n\n// ============================================================================\n// VALIDATION\n// ============================================================================\n\n/**\r\n * Validate element có thể nhận children không\r\n */\nexport const canAcceptChildren = elementType => {\n  const containerTypes = ['section', 'container', 'div', 'flex', 'grid'];\n  return containerTypes.includes(elementType);\n};\n\n/**\r\n * Validate drop có hợp lệ không\r\n */\nexport const isValidDrop = (draggedElement, targetElement) => {\n  // Không thể drop element vào chính nó\n  if (draggedElement.id === targetElement.id) {\n    return false;\n  }\n\n  // Check target có thể nhận children\n  if (!canAcceptChildren(targetElement.type)) {\n    return false;\n  }\n\n  // Không thể drop parent vào child của nó (prevent recursion)\n  if (isDescendant(targetElement, draggedElement.id)) {\n    return false;\n  }\n  return true;\n};\n\n/**\r\n * Check xem element có phải descendant của parentId không\r\n */\nconst isDescendant = (element, parentId) => {\n  if (!element.children || element.children.length === 0) {\n    return false;\n  }\n  for (const child of element.children) {\n    if (child.id === parentId) {\n      return true;\n    }\n    if (isDescendant(child, parentId)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport default {\n  // Constants\n  ItemTypes,\n  GRID_SIZE,\n  SNAP_THRESHOLD,\n  AUTO_SPACING,\n  // Position calculation\n  getAbsolutePosition,\n  getRelativePosition,\n  getCanvasPosition,\n  isPointInElement,\n  findParentAtPosition,\n  // Snapping & grid\n  snapToGrid,\n  generateSnapPoints,\n  getElementBounds,\n  // Auto layout\n  calculateChildPosition,\n  autoLayoutChildren,\n  constrainChildrenToParent,\n  // Drag & drop\n  handleDropNewElement,\n  handleMoveElement,\n  // Validation\n  canAcceptChildren,\n  isValidDrop,\n  // Utilities\n  toKebabCase,\n  processStyles,\n  getCleanTextStyles\n};","map":{"version":3,"names":["toast","ItemTypes","ELEMENT","EXISTING_ELEMENT","CHILD_ELEMENT","GRID_SIZE","SNAP_THRESHOLD","AUTO_SPACING","vertical","horizontal","padding","getAbsolutePosition","element","parentElement","_element$position","_parentElement$positi","elementPos","position","desktop","x","y","z","parentPos","Math","max","getRelativePosition","absolutePos","_parentElement$positi2","getCanvasPosition","mouseX","mouseY","containerElement","zoomLevel","console","error","rect","getBoundingClientRect","scrollX","scrollLeft","scrollY","scrollTop","rawX","left","rawY","top","_parentElement$positi3","parentSize","size","width","height","min","isPointInElement","point","_element$position2","pos","findParentAtPosition","elements","excludeId","containers","filter","el","type","id","length","reduce","highest","current","_current$position","_current$position$des","_highest$position","_highest$position$des","currentZ","highestZ","snapToGrid","gridSize","snapPoints","enabled","snappedX","round","snappedY","forEach","abs","generateSnapPoints","points","bounds","getElementBounds","push","right","bottom","centerX","centerY","viewMode","_element$position3","calculateChildPosition","existingChildren","mode","dropPosition","maxBottom","child","_child$position","childPos","childSize","autoLayoutChildren","children","currentY","map","updatedChild","constrainChildrenToParent","_child$position2","constrainedX","constrainedY","handleDropNewElement","item","mousePosition","allElements","layoutMode","relativePos","autoPos","canvasPos","snapped","handleMoveElement","newPosition","snapEnabled","_element$position4","_element$position4$de","finalPosition","elementSize","toKebabCase","str","replace","m","toLowerCase","processStyles","styles","className","cssString","keyframes","Object","entries","key","value","startsWith","prop","val","p","v","frames","percentage","props","getCleanTextStyles","originalStyles","cleaned","propertiesToRemove","margin","boxSizing","display","canAcceptChildren","elementType","containerTypes","includes","isValidDrop","draggedElement","targetElement","isDescendant","parentId"],"sources":["F:/landinghub-iconic/apps/web/src/components/create-page/helpers.js"],"sourcesContent":["/**\r\n * CANVAS UTILITIES - IMPROVED VERSION\r\n * Fixes:\r\n * 1. Drag & Drop vào Section\r\n * 2. Child element positioning (tọa độ tự do)\r\n * 3. Auto spacing & layout\r\n */\r\n\r\nimport { toast } from 'react-toastify';\r\n\r\n// ============================================================================\r\n// CONSTANTS\r\n// ============================================================================\r\n\r\nexport const ItemTypes = {\r\n    ELEMENT: 'element',\r\n    EXISTING_ELEMENT: 'existingElement',\r\n    CHILD_ELEMENT: 'childElement',\r\n};\r\n\r\nexport const GRID_SIZE = 10;\r\nexport const SNAP_THRESHOLD = 15;\r\n\r\n// Default spacing cho auto layout\r\nexport const AUTO_SPACING = {\r\n    vertical: 20,   // Khoảng cách giữa các elements theo chiều dọc\r\n    horizontal: 20, // Khoảng cách giữa các elements theo chiều ngang\r\n    padding: 20,    // Padding từ parent container\r\n};\r\n\r\n// ============================================================================\r\n// POSITION CALCULATION\r\n// ============================================================================\r\n\r\n/**\r\n * Tính position tuyệt đối trong canvas (bao gồm cả nested elements)\r\n */\r\nexport const getAbsolutePosition = (element, parentElement = null) => {\r\n    const elementPos = element.position?.desktop || { x: 0, y: 0, z: 1 };\r\n\r\n    if (!parentElement) {\r\n        return elementPos;\r\n    }\r\n\r\n    const parentPos = parentElement.position?.desktop || { x: 0, y: 0, z: 1 };\r\n\r\n    return {\r\n        x: parentPos.x + elementPos.x,\r\n        y: parentPos.y + elementPos.y,\r\n        z: Math.max(parentPos.z || 1, elementPos.z || 1)\r\n    };\r\n};\r\n\r\n/**\r\n * Tính position tương đối so với parent\r\n */\r\nexport const getRelativePosition = (absolutePos, parentElement) => {\r\n    if (!parentElement) {\r\n        return absolutePos;\r\n    }\r\n\r\n    const parentPos = parentElement.position?.desktop || { x: 0, y: 0, z: 1 };\r\n\r\n    return {\r\n        x: absolutePos.x - parentPos.x,\r\n        y: absolutePos.y - parentPos.y,\r\n        z: absolutePos.z || 1\r\n    };\r\n};\r\n\r\n/**\r\n * Tính canvas position từ mouse event\r\n * FIXED: Xử lý cả nested containers (section)\r\n */\r\nexport const getCanvasPosition = (mouseX, mouseY, containerElement, zoomLevel = 100, parentElement = null) => {\r\n    if (!containerElement) {\r\n        console.error('Container element is null in getCanvasPosition');\r\n        return { x: 0, y: 0 };\r\n    }\r\n\r\n    const rect = containerElement.getBoundingClientRect();\r\n    const scrollX = containerElement.scrollLeft || 0;\r\n    const scrollY = containerElement.scrollTop || 0;\r\n\r\n    // Tính position tuyệt đối trong canvas\r\n    const rawX = (mouseX - rect.left + scrollX) / (zoomLevel / 100);\r\n    const rawY = (mouseY - rect.top + scrollY) / (zoomLevel / 100);\r\n\r\n    let x = Math.max(0, rawX);\r\n    let y = Math.max(0, rawY);\r\n\r\n    // Nếu có parent element (drop vào section), tính relative position\r\n    if (parentElement) {\r\n        const parentPos = parentElement.position?.desktop || { x: 0, y: 0 };\r\n        x = Math.max(0, x - parentPos.x);\r\n        y = Math.max(0, y - parentPos.y);\r\n\r\n        // Constrain trong bounds của parent\r\n        const parentSize = parentElement.size || { width: 1200, height: 400 };\r\n        x = Math.min(x, parentSize.width - 50);\r\n        y = Math.min(y, parentSize.height - 50);\r\n    }\r\n\r\n    return { x, y };\r\n};\r\n\r\n/**\r\n * Check xem point có nằm trong element bounds không\r\n */\r\nexport const isPointInElement = (point, element) => {\r\n    const pos = element.position?.desktop || { x: 0, y: 0 };\r\n    const size = element.size || { width: 200, height: 50 };\r\n\r\n    return (\r\n        point.x >= pos.x &&\r\n        point.x <= pos.x + size.width &&\r\n        point.y >= pos.y &&\r\n        point.y <= pos.y + size.height\r\n    );\r\n};\r\n\r\n/**\r\n * Tìm parent element chứa point (cho nested drop)\r\n */\r\nexport const findParentAtPosition = (point, elements, excludeId = null) => {\r\n    // Lọc các elements có thể là container (section, container, etc)\r\n    const containers = elements.filter(el =>\r\n        el.type === 'section' &&\r\n        el.id !== excludeId &&\r\n        isPointInElement(point, el)\r\n    );\r\n\r\n    // Return container có z-index cao nhất\r\n    if (containers.length === 0) return null;\r\n\r\n    return containers.reduce((highest, current) => {\r\n        const currentZ = current.position?.desktop?.z || 1;\r\n        const highestZ = highest.position?.desktop?.z || 1;\r\n        return currentZ > highestZ ? current : highest;\r\n    });\r\n};\r\n\r\n// ============================================================================\r\n// SNAPPING & GRID\r\n// ============================================================================\r\n\r\n/**\r\n * Snap to grid với smart snapping\r\n */\r\nexport const snapToGrid = (x, y, gridSize = GRID_SIZE, snapPoints = [], enabled = true) => {\r\n    if (!enabled) {\r\n        return { x, y };\r\n    }\r\n\r\n    let snappedX = Math.round(x / gridSize) * gridSize;\r\n    let snappedY = Math.round(y / gridSize) * gridSize;\r\n\r\n    // Snap to nearby elements\r\n    snapPoints.forEach((point) => {\r\n        if (Math.abs(x - point.x) < SNAP_THRESHOLD) snappedX = point.x;\r\n        if (Math.abs(y - point.y) < SNAP_THRESHOLD) snappedY = point.y;\r\n    });\r\n\r\n    return { x: snappedX, y: snappedY };\r\n};\r\n\r\n/**\r\n * Generate snap points từ tất cả elements\r\n */\r\nexport const generateSnapPoints = (elements, excludeId = null) => {\r\n    const points = [];\r\n\r\n    elements.forEach(element => {\r\n        if (element.id === excludeId) return;\r\n\r\n        const bounds = getElementBounds(element);\r\n\r\n        // Add các edge points\r\n        points.push(\r\n            { x: bounds.left, y: bounds.top },\r\n            { x: bounds.right, y: bounds.top },\r\n            { x: bounds.left, y: bounds.bottom },\r\n            { x: bounds.right, y: bounds.bottom },\r\n            { x: bounds.centerX, y: bounds.centerY }\r\n        );\r\n    });\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n * Get element bounds\r\n */\r\nexport const getElementBounds = (element, viewMode = 'desktop') => {\r\n    const pos = element.position?.[viewMode] || { x: 0, y: 0 };\r\n    const size = element.size || { width: 200, height: 50 };\r\n\r\n    return {\r\n        left: pos.x,\r\n        top: pos.y,\r\n        right: pos.x + size.width,\r\n        bottom: pos.y + size.height,\r\n        centerX: pos.x + size.width / 2,\r\n        centerY: pos.y + size.height / 2,\r\n        width: size.width,\r\n        height: size.height,\r\n    };\r\n};\r\n\r\n// ============================================================================\r\n// AUTO LAYOUT & SPACING\r\n// ============================================================================\r\n\r\n/**\r\n * Tính position tự động cho child element mới\r\n * Có 2 modes: 'flow' (auto spacing) và 'free' (tọa độ tự do)\r\n */\r\nexport const calculateChildPosition = (\r\n    parentElement,\r\n    existingChildren = [],\r\n    mode = 'flow', // 'flow' hoặc 'free'\r\n    dropPosition = null // Position khi drop (cho free mode)\r\n) => {\r\n    const parentSize = parentElement.size || { width: 1200, height: 400 };\r\n    const padding = AUTO_SPACING.padding;\r\n\r\n    if (mode === 'free' && dropPosition) {\r\n        // Free positioning - sử dụng drop position\r\n        return {\r\n            x: Math.max(padding, Math.min(dropPosition.x, parentSize.width - padding - 100)),\r\n            y: Math.max(padding, Math.min(dropPosition.y, parentSize.height - padding - 50)),\r\n            z: 2 // Child elements có z-index cao hơn parent\r\n        };\r\n    }\r\n\r\n    // Flow mode - auto spacing theo chiều dọc\r\n    if (existingChildren.length === 0) {\r\n        // Child đầu tiên\r\n        return {\r\n            x: padding,\r\n            y: padding,\r\n            z: 2\r\n        };\r\n    }\r\n\r\n    // Tìm child thấp nhất\r\n    let maxBottom = padding;\r\n    existingChildren.forEach(child => {\r\n        const childPos = child.position?.desktop || { x: padding, y: padding };\r\n        const childSize = child.size || { width: 200, height: 50 };\r\n        const bottom = childPos.y + childSize.height;\r\n        if (bottom > maxBottom) {\r\n            maxBottom = bottom;\r\n        }\r\n    });\r\n\r\n    // Child mới nằm dưới child thấp nhất\r\n    return {\r\n        x: padding,\r\n        y: maxBottom + AUTO_SPACING.vertical,\r\n        z: 2\r\n    };\r\n};\r\n\r\n/**\r\n * Auto-layout lại tất cả children trong parent\r\n * Useful sau khi delete hoặc reorder\r\n */\r\nexport const autoLayoutChildren = (parentElement, children, mode = 'flow') => {\r\n    if (mode === 'free') {\r\n        // Free mode - giữ nguyên positions\r\n        return children;\r\n    }\r\n\r\n    const padding = AUTO_SPACING.padding;\r\n    let currentY = padding;\r\n\r\n    return children.map(child => {\r\n        const childSize = child.size || { width: 200, height: 50 };\r\n\r\n        const updatedChild = {\r\n            ...child,\r\n            position: {\r\n                ...child.position,\r\n                desktop: {\r\n                    x: padding,\r\n                    y: currentY,\r\n                    z: 2\r\n                }\r\n            }\r\n        };\r\n\r\n        currentY += childSize.height + AUTO_SPACING.vertical;\r\n\r\n        return updatedChild;\r\n    });\r\n};\r\n\r\n/**\r\n * Check và fix overflow children\r\n */\r\nexport const constrainChildrenToParent = (parentElement, children) => {\r\n    const parentSize = parentElement.size || { width: 1200, height: 400 };\r\n    const padding = AUTO_SPACING.padding;\r\n\r\n    return children.map(child => {\r\n        const childPos = child.position?.desktop || { x: 0, y: 0 };\r\n        const childSize = child.size || { width: 200, height: 50 };\r\n\r\n        const constrainedX = Math.max(\r\n            padding,\r\n            Math.min(childPos.x, parentSize.width - childSize.width - padding)\r\n        );\r\n\r\n        const constrainedY = Math.max(\r\n            padding,\r\n            Math.min(childPos.y, parentSize.height - childSize.height - padding)\r\n        );\r\n\r\n        if (constrainedX !== childPos.x || constrainedY !== childPos.y) {\r\n            return {\r\n                ...child,\r\n                position: {\r\n                    ...child.position,\r\n                    desktop: {\r\n                        x: constrainedX,\r\n                        y: constrainedY,\r\n                        z: childPos.z || 2\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        return child;\r\n    });\r\n};\r\n\r\n// ============================================================================\r\n// DRAG & DROP HANDLERS\r\n// ============================================================================\r\n\r\n/**\r\n * Handle drop element mới vào canvas/section\r\n */\r\nexport const handleDropNewElement = (\r\n    item,\r\n    mousePosition,\r\n    containerElement,\r\n    zoomLevel,\r\n    allElements,\r\n    parentElement = null,\r\n    layoutMode = 'flow'\r\n) => {\r\n    let position;\r\n\r\n    if (parentElement) {\r\n        // Drop vào section\r\n        if (layoutMode === 'free') {\r\n            // Tọa độ tự do - dùng mouse position\r\n            const relativePos = getCanvasPosition(\r\n                mousePosition.x,\r\n                mousePosition.y,\r\n                containerElement,\r\n                zoomLevel,\r\n                parentElement\r\n            );\r\n            position = {\r\n                desktop: { x: relativePos.x, y: relativePos.y, z: 2 }\r\n            };\r\n        } else {\r\n            // Flow mode - auto positioning\r\n            const children = parentElement.children || [];\r\n            const autoPos = calculateChildPosition(parentElement, children, 'flow');\r\n            position = { desktop: autoPos };\r\n        }\r\n    } else {\r\n        // Drop vào canvas chính\r\n        const canvasPos = getCanvasPosition(\r\n            mousePosition.x,\r\n            mousePosition.y,\r\n            containerElement,\r\n            zoomLevel\r\n        );\r\n\r\n        // Snap to grid\r\n        const snapPoints = generateSnapPoints(allElements);\r\n        const snapped = snapToGrid(canvasPos.x, canvasPos.y, GRID_SIZE, snapPoints);\r\n\r\n        position = {\r\n            desktop: { x: snapped.x, y: snapped.y, z: 1 }\r\n        };\r\n    }\r\n\r\n    return position;\r\n};\r\n\r\n/**\r\n * Handle di chuyển existing element\r\n */\r\nexport const handleMoveElement = (\r\n    element,\r\n    newPosition,\r\n    allElements,\r\n    parentElement = null,\r\n    snapEnabled = true\r\n) => {\r\n    let finalPosition = { ...newPosition };\r\n\r\n    if (snapEnabled && !parentElement) {\r\n        // Snap to grid (chỉ trên canvas chính)\r\n        const snapPoints = generateSnapPoints(allElements, element.id);\r\n        finalPosition = snapToGrid(newPosition.x, newPosition.y, GRID_SIZE, snapPoints);\r\n    }\r\n\r\n    if (parentElement) {\r\n        // Constrain trong parent bounds\r\n        const parentSize = parentElement.size || { width: 1200, height: 400 };\r\n        const elementSize = element.size || { width: 200, height: 50 };\r\n        const padding = AUTO_SPACING.padding;\r\n\r\n        finalPosition.x = Math.max(\r\n            padding,\r\n            Math.min(finalPosition.x, parentSize.width - elementSize.width - padding)\r\n        );\r\n        finalPosition.y = Math.max(\r\n            padding,\r\n            Math.min(finalPosition.y, parentSize.height - elementSize.height - padding)\r\n        );\r\n    }\r\n\r\n    return {\r\n        desktop: {\r\n            x: finalPosition.x,\r\n            y: finalPosition.y,\r\n            z: newPosition.z || element.position?.desktop?.z || 1\r\n        }\r\n    };\r\n};\r\n\r\n// ============================================================================\r\n// UTILITIES\r\n// ============================================================================\r\n\r\n/**\r\n * Convert camelCase to kebab-case\r\n */\r\nexport const toKebabCase = (str) =>\r\n    str.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);\r\n\r\n/**\r\n * Process styles including pseudo-classes\r\n */\r\nexport const processStyles = (styles, className) => {\r\n    let cssString = '';\r\n    const keyframes = {};\r\n\r\n    Object.entries(styles).forEach(([key, value]) => {\r\n        if (key.startsWith(':')) {\r\n            cssString += `.${className}${key} { `;\r\n            Object.entries(value).forEach(([prop, val]) => {\r\n                if (prop.startsWith('::')) {\r\n                    cssString += `.${className}${prop} { `;\r\n                    Object.entries(val).forEach(([p, v]) => {\r\n                        cssString += `${toKebabCase(p)}: ${v}; `;\r\n                    });\r\n                    cssString += '} ';\r\n                } else {\r\n                    cssString += `${toKebabCase(prop)}: ${val}; `;\r\n                }\r\n            });\r\n            cssString += '} ';\r\n        } else if (key.startsWith('@keyframes')) {\r\n            keyframes[key] = value;\r\n        } else {\r\n            cssString += `${toKebabCase(key)}: ${value}; `;\r\n        }\r\n    });\r\n\r\n    Object.entries(keyframes).forEach(([key, frames]) => {\r\n        cssString += `${key} { `;\r\n        Object.entries(frames).forEach(([percentage, props]) => {\r\n            cssString += `${percentage} { `;\r\n            Object.entries(props).forEach(([prop, val]) => {\r\n                cssString += `${toKebabCase(prop)}: ${val}; `;\r\n            });\r\n            cssString += '} ';\r\n        });\r\n        cssString += '} ';\r\n    });\r\n\r\n    return cssString;\r\n};\r\n\r\n/**\r\n * Get clean text styles (remove incompatible properties)\r\n */\r\nexport const getCleanTextStyles = (originalStyles) => {\r\n    const cleaned = { ...originalStyles };\r\n    const propertiesToRemove = [\r\n        'border',\r\n        'borderRadius',\r\n        'boxShadow',\r\n        'backgroundColor',\r\n        'background',\r\n        'backgroundImage',\r\n        'backgroundSize',\r\n        'backgroundPosition',\r\n        'padding',\r\n        'paddingLeft',\r\n        'paddingRight',\r\n        'paddingTop',\r\n        'paddingBottom',\r\n    ];\r\n\r\n    propertiesToRemove.forEach((prop) => delete cleaned[prop]);\r\n\r\n    return {\r\n        ...cleaned,\r\n        margin: cleaned.margin || '0',\r\n        boxSizing: 'border-box',\r\n        display: cleaned.display || 'block',\r\n        width: cleaned.width || '100%',\r\n        height: cleaned.height || 'auto',\r\n    };\r\n};\r\n\r\n// ============================================================================\r\n// VALIDATION\r\n// ============================================================================\r\n\r\n/**\r\n * Validate element có thể nhận children không\r\n */\r\nexport const canAcceptChildren = (elementType) => {\r\n    const containerTypes = ['section', 'container', 'div', 'flex', 'grid'];\r\n    return containerTypes.includes(elementType);\r\n};\r\n\r\n/**\r\n * Validate drop có hợp lệ không\r\n */\r\nexport const isValidDrop = (draggedElement, targetElement) => {\r\n    // Không thể drop element vào chính nó\r\n    if (draggedElement.id === targetElement.id) {\r\n        return false;\r\n    }\r\n\r\n    // Check target có thể nhận children\r\n    if (!canAcceptChildren(targetElement.type)) {\r\n        return false;\r\n    }\r\n\r\n    // Không thể drop parent vào child của nó (prevent recursion)\r\n    if (isDescendant(targetElement, draggedElement.id)) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n/**\r\n * Check xem element có phải descendant của parentId không\r\n */\r\nconst isDescendant = (element, parentId) => {\r\n    if (!element.children || element.children.length === 0) {\r\n        return false;\r\n    }\r\n\r\n    for (const child of element.children) {\r\n        if (child.id === parentId) {\r\n            return true;\r\n        }\r\n        if (isDescendant(child, parentId)) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n// ============================================================================\r\n// EXPORTS\r\n// ============================================================================\r\n\r\nexport default {\r\n    // Constants\r\n    ItemTypes,\r\n    GRID_SIZE,\r\n    SNAP_THRESHOLD,\r\n    AUTO_SPACING,\r\n\r\n    // Position calculation\r\n    getAbsolutePosition,\r\n    getRelativePosition,\r\n    getCanvasPosition,\r\n    isPointInElement,\r\n    findParentAtPosition,\r\n\r\n    // Snapping & grid\r\n    snapToGrid,\r\n    generateSnapPoints,\r\n    getElementBounds,\r\n\r\n    // Auto layout\r\n    calculateChildPosition,\r\n    autoLayoutChildren,\r\n    constrainChildrenToParent,\r\n\r\n    // Drag & drop\r\n    handleDropNewElement,\r\n    handleMoveElement,\r\n\r\n    // Validation\r\n    canAcceptChildren,\r\n    isValidDrop,\r\n\r\n    // Utilities\r\n    toKebabCase,\r\n    processStyles,\r\n    getCleanTextStyles,\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}